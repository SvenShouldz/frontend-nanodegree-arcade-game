
// CONFIGURATION
var conf = {
    "colWidth":100,
    "rowHeight":100,
    "colCount":8,
    "rowCount":6,
    "enemySpeed":300,
    "enemyLimit":10,
    "topLanes":[110,210],
    "bottomLanes":[310,410],
    "playerSpeed":200,
    "collision":true,
    "endScreen":false,
    "allowedKeys": {37: 'left',38: 'up',39: 'right',40: 'down'},
    "pressedKeys": {}
};

    // sets size for canvas element
    conf.canvasWidth = Math.floor(conf.colCount * conf.colWidth);
    conf.canvasHeight = Math.floor(conf.rowCount * conf.rowHeight);

/**
* @description Enemy Object which is generated by enemy.generate()
* @constructor
* @param {number} dir - Sets direction
* @param {number} y - Sets lane
* @param {string} sprite - Sets car color
*/
var Enemy = function(dir, y, sprite) {
    this.width = 135;
    this.height = 84;
    this.halfWidth = this.width * 0.5;
    this.halfHeight = this.height * 0.5;
    this.sprite = sprite;
    this.speed = conf.enemySpeed;
    this.x = dir;
    this.y = y;
};

Enemy.prototype = {
    /**
    * @description Updates position of Enemy() and detects collision with Player()
    * @param {number} dt - time delta information for smooth animation
    */
    update: function(dt) {
        if(this.y > 300){
            this.x = this.x + this.speed * dt;

        }else{
            this.x = this.x - this.speed * dt;

        }

        // TODO: move collision to engine.js

        if(conf.collision === true){
            if (this.getRight() > player.getLeft() && this.getLeft() < player.getRight()){
                if(this.getTop() < player.getBottom() && this.getBottom() > player.getTop()){
                    player.move = false;
                    player.sprite = 'images/dead.png';
                    conf.endScreen = true;
                 }
            }
        }
    },
    /**
    * @description Renders Enemy() on canvas
    */
    render: function() {
        ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
    },
    /**
    * @description Random math function
    * @param {number} min - Defines the minimal number
    * @param {number} max - Defines the maximal number
    * @return {number} Number between min and max
    */
    rnd: function(min, max){
        return Math.ceil(Math.random() * (max - min) + min);
    },
    /**
    * @description Resets all gamestats
    */
    reset: function(){
        player.collect = 0;
        conf.endScreen = false;
        allEnemies = [];
        player = new Player();

        console.log("------RESET------");
    },
    /**
    * @description Generates Enemy() if the conf.enemyLimit is reached it delets the oldest 5 Enemy().
    */
    getStat: function(){
        var y, sprite,
        rnd = this.rnd(-1,1),
        dir = Math.random() < 0.5 ? conf.canvasWidth : -100;

        if(dir > 100){
            var topLane = conf.topLanes[rnd];
            y = topLane;
            spriteArr = ['images/red-car-left.png','images/blue-car-left.png','images/green-car-left.png'];

             sprite = spriteArr[this.rnd(-1,2)];

            return [dir, y, sprite];
        }else{
           var bottomLane = conf.bottomLanes[rnd];
            y = bottomLane;
            spriteArr = ['images/red-car.png','images/blue-car.png','images/green-car.png'];

            sprite = spriteArr[this.rnd(-1,2)];

            return [dir, y, sprite];
        }
    },
    /**
    * @description Gets the middle of x-length for collision
    * return {number}  middle of x-length
    */
    getMidX: function() {
        return this.halfWidth + this.x;
    },
    /**
    * @description Gets the middle of y-length for collision
    * return {number}  middle of y-length
    */
    getMidY: function() {
        return this.halfHeight + this.y;
    },
    /**
    * @description Gets y position for collision
    * return {number}  y position
    */
    getTop: function() {
        return this.y;
    },
    /**
    * @description Gets x position for collision
    * return {number} x position
    */
    getLeft: function() {
        return this.x;
    },
    /**
    * @description Gets the right of x-length for collision
    * return {number}  right of x-length
    */
    getRight: function() {
        return this.x + this.width;
    },
    /**
    * @description Gets the bottom of y-length for collision
    * return {number}  bottom of y-length
    */
    getBottom: function() {
        return this.y + this.height;
    }

};
/**
* @description Player Object which will be created on start
* @constructor
*/
var Player = function(){
    this.width = 58;
    this.height = 29;
    this.halfWidth = this.width * 0.5;
    this.halfHeight = this.height * 0.5;
    this.sprite = 'images/char-up.png';
    this.speed = conf.playerSpeed;
    this.x = Math.floor(conf.canvasWidth / 2 - this.width / 2);
    this.y = Math.floor(conf.canvasHeight - this.height - 30);
    this.collect = 0;
    this.dir = "stop";
    this.move = true;
};

Player.prototype = {
    /**
    * @description Renders Player() on canvas
    */
    render: function(){
     ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
    },
    /**
    * @description checks for pressed keys and translates into strings for player.update()
    */
    control: function(){
            if(conf.pressedKeys['37']){this.dir = "left";}
                else if (conf.pressedKeys['38']){this.dir = "up";}
                else if (conf.pressedKeys['39']){this.dir = "right";}
                else if (conf.pressedKeys['40']){this.dir = "down";}
                else{this.dir = "stop";}
    },
    /**
    * @description updates position & sprites of Player()
    * @param {number} dt - time delta information for smooth animation
    */
    update: function(dt){
        if(this.move === true){
           switch(this.dir){
            case 'stop':
                this.x = this.x;
                break;
            case 'left':
                if(this.x < 0){
                    this.dir = 'stop';
                }else{
                    this.x = this.x - conf.playerSpeed * dt;
                    this.sprite = 'images/char-left.png';
                    this.width = 30;
                    this.height = 60;
                }
                break;
            case 'right':
                if(this.x > conf.canvasWidth - this.width){
                    this.dir = 'stop';
                }else{
                    this.x = this.x + conf.playerSpeed * dt;
                    this.sprite = 'images/char-right.png';
                    this.width = 30;
                    this.height = 60;
                }
                break;
            case 'up':
                if(this.y < 0){
                    this.dir = 'stop';
                }else{
                    this.y = this.y - conf.playerSpeed * dt;
                    this.sprite = 'images/char-up.png';
                    this.width = 60;
                    this.height = 30;
                }
                break;
            case 'down':
                if(this.y > conf.canvasHeight - this.height){
                    this.dir = 'stop';
                }else{
                    this.y = this.y + conf.playerSpeed * dt;
                    this.sprite = 'images/char-down.png';
                    this.width = 60;
                    this.height = 30;
                }
                break;
            }
        }
    },
    /**
    * @description Gets the middle of x-length for collision
    * return {number}  middle of x-length
    */
    getMidX: function() {
        return this.halfWidth + this.x;
    },
    /**
    * @description Gets the middle of y-length for collision
    * return {number}  middle of y-length
    */
    getMidY: function() {
        return this.halfHeight + this.y;
    },
    /**
    * @description Gets y position for collision
    * return {number}  y position
    */
    getTop: function() {
        return this.y;
    },
    /**
    * @description Gets x position for collision
    * return {number} x position
    */
    getLeft: function() {
        return this.x;
    },
    /**
    * @description Gets the right of x-length for collision
    * return {number}  right of x-length
    */
    getRight: function() {
        return this.x + this.width;
    },
    /**
    * @description Gets the bottom of y-length for collision
    * return {number}  bottom of y-length
    */
    getBottom: function() {
        return this.y + this.height;
    }
};
/**
* @description Item Object generated by item.generate()
* @constructor
* @param {number} tileX - Sets x position of Item()
* @param {number} tileY - Sets y position of Item()
*/
var Item = function(tileX, tileY){
    this.width = 40;
    this.height = 40;
    this.halfWidth = this.width * 0.5;
    this.halfHeight = this.height * 0.5;
    this.x = tileX;
    this.y = tileY;
    this.points = 100;
    this.sprite = 'images/coin.png';
    this.active = true;
};

Item.prototype = {
    /*
    * @description Renders Item() on the canvas element
    */
    render: function(){
        ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
    },
    /*
    * @description detects collision between Item() and Player()
    */
    collision: function(){
            if (this.getRight() > player.getLeft() && this.getLeft() < player.getRight()){
                if(this.getTop() < player.getBottom() && this.getBottom() > player.getTop()){
                    player.collect += this.points;
                    this.active = false;
                    this.generate();
                }
            }
    },
    /*
    * @description sets randomly generated positions for Item()
    */
    generate:function(){
       var tile = this.tile();
        this.x = tile[0];
        this.y = tile[1];
        this.active = true;
    },
    /*
    * @description Random math function
    * @param {number} min - Defines the minimal number
    * @param {number} max - Defines the maximal number
    * @return {number} Number between min and max
    */
    rnd: function(min, max){
        return Math.ceil(Math.random() * (max - min) + min);
    },
    /*
    * @description picks a random tile where Item() should be shown
    */
    tile: function(){
        var width = conf.colWidth;
        var height = conf.rowHeight;
        var tileCol = this.rnd(0, Math.floor(conf.canvasWidth / width));
        var tileRow = this.rnd(100,500);

        var tileX = tileCol * width - 100;
        var tileY = tileRow;

        return [tileX, tileY];
    },
    /*
    * @description Gets the middle of x-length for collision
    * return {number}  middle of x-length
    */
    getMidX: function() {
        return this.halfWidth + this.x;
    },
    /*
    * @description Gets the middle of y-length for collision
    * return {number}  middle of y-length
    */
    getMidY: function() {
        return this.halfHeight + this.y;
    },
    /*
    * @description Gets y position for collision
    * return {number}  y position
    */
    getTop: function() {
        return this.y;
    },
    /*
    *
    * @description Gets x position for collision
    * return {number} x position
    */
    getLeft: function() {
        return this.x;
    },
    /*
    * @description Gets the right of x-length for collision
    * return {number}  right of x-length
    */
    getRight: function() {
        return this.x + this.width;
    },
    /*
     * @description Gets the bottom of y-length for collision
     * return {number}  bottom of y-length
     */
    getBottom: function() {
        return this.y + this.height;
    }

};

/*
 * @description Generates Enemy() if the conf.enemyLimit is reached it delets the oldest 5 Enemy().
 */
function generator(){
            window.setInterval(function(){

            var stats = enemy.getStat();

            if(allEnemies.length >= conf.enemyLimit){
                allEnemies.splice(0, 5);
            }

            setTimeout(function(){
                allEnemies.push(new Enemy(stats[0], stats[1], stats[2]));
            }, enemy.rnd(0,200));


        }, 700);
}

// Creates Objects on start and generates new ones the whole time
var player = new Player();
var enemy = new Enemy();
var item = new Item();
var allEnemies = [];

item.generate();

generator();

/*
 * @description Listens for keydown and keyup events
 */
document.addEventListener('keydown', function(e) {
    e.preventDefault();
    if(conf.allowedKeys[e.keyCode]){
        conf.pressedKeys[e.keyCode] = true;
    }
});

document.addEventListener('keyup', function(e) {
    if(conf.allowedKeys[e.keyCode]){
        delete conf.pressedKeys[e.keyCode];
    }
    e.preventDefault();
});



